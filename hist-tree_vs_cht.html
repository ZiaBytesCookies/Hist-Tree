<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hist-Tree vs. Compact Hist-Tree (CHT) Comparison</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; background-color: #eef1f5; color: #333; }
        .main-container { display: grid; grid-template-columns: 380px 1fr; gap: 20px; } /* Wider controls */
        .controls-section { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .visualizations-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .viz-column { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        
        h1, h2, h3 { color: #345a7e; }
        h2 { margin-top: 0; border-bottom: 2px solid #d0d9e2; padding-bottom: 5px;}
        h3 { margin-bottom: 5px; margin-top: 15px; }
        
        input, button { padding: 9px; margin: 6px 0; border-radius: 5px; }
        input { border: 1px solid #ccc; width: calc(100% - 20px); }
        button { background-color: #5c89b4; color: white; border: none; cursor: pointer; transition: background-color 0.2s; width: 100%; }
        button:hover { background-color: #4a78a0; }
        button#generate-build { background-color: #4CAF50; }
        button#generate-build:hover { background-color: #45a049; }
        button#do-lookup { background-color: #f0ad4e; }
        button#do-lookup:hover { background-color: #efa03a; }

        .info-box {
            max-height: 100px; overflow-y: auto; border: 1px solid #e0e0e0; padding: 8px; margin-top: 8px;
            background-color: #f9f9f9; border-radius: 4px; font-size: 0.85em; word-break: break-all;
        }
        #lookup-result-area { margin-top: 10px; font-weight: bold; color: #345a7e; padding: 10px; background-color: #dfe8f0; border-radius: 4px; text-align: center;}
        #error-display { color: #d9534f; font-weight: bold; padding: 10px; margin-top: 10px; border: 1px solid #f5c6cb; background-color: #f8d7da; border-radius: 4px; display: none; }

        /* Hist-Tree Specific Styles */
        .hist-tree-node-container { display: flex; margin-bottom: 8px; position: relative; }
        .hist-tree-bin {
            padding: 5px 7px; border: 1px solid rgba(0,0,0,0.1); margin-right: 4px; min-width: 70px; min-height: 35px; /* Adjusted for space */
            display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;
            position: relative; border-radius: 3px; box-shadow: 0 1px 2px rgba(0,0,0,0.08); font-size: 0.7em; /* Smaller font */
        }
        .hist-tree-bin-terminal { background: linear-gradient(to bottom right, #ffdddd, #ffe8dd); color: #b05a46; }
        .hist-tree-bin-non-terminal { background: linear-gradient(to bottom right, #dde5ff, #cce8ff); color: #2a5c9a; }
        .hist-tree-connector { position: absolute; border-left: 2px solid #5c89b4; width: 2px; height: 10px; bottom: -10px; left: 50%; transform: translateX(-50%); } /* Smaller connector */
        .hist-tree-highlighted-bin { border: 2px solid #ff8c00; transform: scale(1.03); box-shadow: 0 0 8px rgba(255,140,0,0.5); }

        /* CHT Table Styles */
        .cht-table-container { margin-top: 10px; max-height: 280px; overflow: auto; } 
        .cht-table { border-collapse: collapse; width: 100%; font-size: 0.75em; } /* Smaller font */
        .cht-table th, .cht-table td { border: 1px solid #b0c4de; padding: 4px; text-align: center; } /* Reduced padding */
        .cht-table th { background-color: #6f8faf; color: white; }
        .cht-bin-terminal { background-color: #e0e0e0; color: #424242; }
        .cht-bin-offset { background-color: #e3f2fd; color: #1565c0; }
        .cht-row-highlight { background-color: #fff9c4 !important; }
        .cht-bin-highlight { box-shadow: 0 0 0 2px #ffb300 inset; font-weight: bold; }
        
        .lookup-steps-display { margin-top:10px; font-size: 0.75em; padding-right: 5px; } /* Smaller font */
        .lookup-step-item { margin-bottom: 6px; padding: 6px; background-color: #f7f9fc; border-radius: 4px; border-left: 3px solid #7ba2c8;}
        .final-lookup-step { background-color: #e8f5e9; border-left-color: #66bb6a; font-weight: bold; }

        /* Performance Graph Styles */
        .perf-graph-container { margin-top: 15px; }
        .bars-area {
            display: flex; align-items: flex-end; justify-content: space-around; 
            height: 80px; /* Shorter graph */
            border-bottom: 1px solid #b0bec5; padding-top: 20px; margin-bottom: 3px;
        }
        .bars-area .bar {
            width: 50px; /* Narrower bars */
            text-align: center; color: white; font-size: 0.8em; 
            border-radius: 3px 3px 0 0; position: relative; transition: height 0.3s ease-out;
        }
        .bars-area .bar .value-label {
            position: absolute; top: -18px; left: 50%; transform: translateX(-50%);
            font-size: 0.85em; font-weight: bold; color: #333;
        }
        .bars-area .hist-tree-bar { background-color: #5c89b4; }
        .bars-area .cht-bar { background-color: #66bb6a; }
        .perf-summary p { margin: 3px 0; font-size: 0.85em; }
        .x-axis-labels span { width: 50px; text-align: center; font-size: 0.8em; }

        .metrics-display { font-size: 0.9em; margin-top: 5px; }
        .metrics-display p { margin: 3px 0; }
    </style>
</head>
<body>
    <h1>Hist-Tree vs. Compact Hist-Tree (CHT) Comparison</h1>
    <p>Compare Hist-Tree and CHT structures, lookup paths, and performance indicators. CHT is a read-optimized, flattened version of Hist-Tree.</p>

    <div id="error-display"></div>

    <div class="main-container">
        <div class="controls-section">
            <h2>Controls & Configuration</h2>
            <div><label for="data-size">Data points (e.g., 50-500):</label><input type="number" id="data-size" value="150" min="10" max="500"></div>
            <div><label for="data-min">Data min:</label><input type="number" id="data-min" value="0"></div>
            <div><label for="data-max">Data max:</label><input type="number" id="data-max" value="10000"></div>
            <div><label for="bins-count">Bins per node (2-6):</label><input type="number" id="bins-count" value="4" min="2" max="6"></div>
            <div><label for="bin-threshold">Terminal Threshold (e.g., 4-20):</label><input type="number" id="bin-threshold" value="8" min="1" max="50"></div>
            
            <button id="generate-build">1. Generate Data & Build Trees</button>

            <h3>Generated Sorted Data</h3>
            <div id="generated-data" class="info-box">Data will appear here.</div>
            
            <h3>Lookup Key</h3>
            <div><label for="lookup-key">Key:</label><input type="number" id="lookup-key" placeholder="e.g., 5000"></div>
            <button id="do-lookup">2. Lookup Key in Both</button>
            <div id="lookup-result-area">Lookup result...</div>
            
            <div id="build-time-metrics" class="metrics-display perf-graph-container">
                <h3>Build Time</h3>
                <!-- Build times will be shown here -->
            </div>

            <div id="structure-size-metrics" class="metrics-display perf-graph-container">
                <h3>Structure Size (Proxy)</h3>
                <div id="size-bars" class="bars-area"></div>
                <div style="display: flex; justify-content: space-around;" class="x-axis-labels">
                    <span>Hist-Tree Nodes</span><span>CHT Rows</span>
                </div>
                <div class="perf-summary size-summary" style="text-align: center;"></div>
            </div>
            
            <div id="lookup-performance-graph-container" class="perf-graph-container">
                <h3>Lookup Performance (Steps)</h3>
                <div id="performance-bars" class="bars-area"></div>
                <div style="display: flex; justify-content: space-around;" class="x-axis-labels">
                    <span>Hist-Tree</span><span>CHT</span>
                </div>
                <div class="perf-summary lookup-summary" style="text-align: center;"></div>
            </div>
        </div>

        <div class="visualizations-container">
            <div class="viz-column">
                <h2>Hist-Tree Visualization</h2>
                <div id="hist-tree-info" class="info-box" style="background-color: #e3f2fd;">Hist-Tree specific info.</div>
                <div id="hist-tree-structure-viz"></div>
                <div id="hist-tree-lookup-steps" class="lookup-steps-display"><h4>Hist-Tree Lookup Path:</h4></div>
            </div>
            <div class="viz-column">
                <h2>Compact Hist-Tree (CHT) Visualization</h2>
                <div id="cht-info" class="info-box" style="background-color: #e8f5e9;">CHT specific info.</div>
                <div id="cht-table-viz" class="cht-table-container"></div>
                <div id="cht-lookup-steps" class="lookup-steps-display"><h4>CHT Lookup Path:</h4></div>
            </div>
        </div>
    </div>

    <script>
        // --- HistTree Class ---
        class HistTree {
            constructor(data, binsPerNode, terminalThreshold) {
                this.data = [...data].sort((a, b) => a - b);
                this.binsPerNode = binsPerNode;
                this.terminalThreshold = terminalThreshold;
                this.globalMinKey = this.data.length > 0 ? this.data[0] : 0;
                this.globalMaxKey = this.data.length > 0 ? this.data[this.data.length - 1] : 1;

                if (this.data.length > 0 && this.globalMinKey === this.globalMaxKey) { this.globalMinKey -= 1; this.globalMaxKey += 1; }
                else if (this.data.length === 0) { this.globalMinKey = 0; this.globalMaxKey = 1; }

                this.rootConceptualRangeWidth = 1;
                const actualKeySpan = this.globalMaxKey - this.globalMinKey + 1;
                while (this.rootConceptualRangeWidth < actualKeySpan) { this.rootConceptualRangeWidth *= 2; }
                this.rootEffectiveMinKey = this.globalMinKey;
                this.maxAllowedDepth = Math.min(10, Math.floor(Math.log2(this.data.length || 1) / Math.log2(this.binsPerNode)) + 4); // Increased slightly
                this.nodeIdCounter = 0; 

                if (this.data.length > 0) {
                    this.root = this.buildNodeRecursive(0, this.data.length - 1, this.rootEffectiveMinKey, this.rootConceptualRangeWidth, 0);
                } else {
                    this.root = { id: `ht-node-${this.nodeIdCounter++}`, isLeaf: true, histogram: [0], children: null, dataStartIndex: 0, dataEndIndex: -1, effectiveMinKey: 0, conceptualRangeWidth: 1, binWidth: 1, depth: 0, isEmptyNode: true, binsPerNode: this.binsPerNode };
                }
            }

            buildNodeRecursive(dataStartIndex, dataEndIndex, nodeEffectiveMinKey, nodeConceptualRangeWidth, depth) {
                const nodeId = `ht-node-${this.nodeIdCounter++}`; 
                const numElementsInNodeRange = dataEndIndex - dataStartIndex + 1;

                if (numElementsInNodeRange <= 0) {
                     return { id: nodeId, isLeaf: true, histogram: Array(this.binsPerNode).fill(0), children: null, dataStartIndex, dataEndIndex, effectiveMinKey: nodeEffectiveMinKey, conceptualRangeWidth: nodeConceptualRangeWidth, binWidth: Math.max(1e-9, nodeConceptualRangeWidth / this.binsPerNode), depth: depth, isEmptyNode: true, binsPerNode: this.binsPerNode };
                }
                const currentBinWidthForNode = Math.max(1e-9, nodeConceptualRangeWidth / this.binsPerNode);

                if (depth >= this.maxAllowedDepth || numElementsInNodeRange <= this.terminalThreshold || nodeConceptualRangeWidth < this.binsPerNode || currentBinWidthForNode < 1) { // Added currentBinWidthForNode < 1 condition
                    const leafHistogram = Array(this.binsPerNode).fill(0);
                    if (this.binsPerNode > 0 && numElementsInNodeRange > 0) leafHistogram[0] = numElementsInNodeRange; 
                    else if (numElementsInNodeRange > 0) leafHistogram.push(numElementsInNodeRange);
                    return { id: nodeId, isLeaf: true, histogram: leafHistogram, children: null, dataStartIndex, dataEndIndex, effectiveMinKey: nodeEffectiveMinKey, conceptualRangeWidth: nodeConceptualRangeWidth, binWidth: currentBinWidthForNode, depth: depth, binsPerNode: this.binsPerNode };
                }
                
                const histogram = Array(this.binsPerNode).fill(0);
                for (let k = dataStartIndex; k <= dataEndIndex; k++) {
                    const keyRelativeToNodeStart = this.data[k] - nodeEffectiveMinKey;
                    let binIndex = 0;
                    if (currentBinWidthForNode > 1e-9) binIndex = Math.floor(keyRelativeToNodeStart / currentBinWidthForNode);
                    binIndex = Math.max(0, Math.min(binIndex, this.binsPerNode - 1));
                    histogram[binIndex]++;
                }

                const children = Array(this.binsPerNode).fill(null);
                let currentDataPointer = dataStartIndex;
                for (let i = 0; i < this.binsPerNode; i++) {
                    const countInThisBin = histogram[i];
                    if (countInThisBin > 0 && countInThisBin > this.terminalThreshold && depth < this.maxAllowedDepth - 1 ) { 
                        const childDataStartIndex = currentDataPointer;
                        const childDataEndIndex = currentDataPointer + countInThisBin - 1;
                        const childEffectiveMinKey = nodeEffectiveMinKey + i * currentBinWidthForNode;
                        if (childDataEndIndex >= childDataStartIndex) {
                            children[i] = this.buildNodeRecursive(childDataStartIndex, childDataEndIndex, childEffectiveMinKey, currentBinWidthForNode, depth + 1); 
                        }
                    }
                    currentDataPointer += countInThisBin;
                }
                return { id: nodeId, isLeaf: false, histogram: histogram, children: children, dataStartIndex, dataEndIndex, effectiveMinKey: nodeEffectiveMinKey, conceptualRangeWidth: nodeConceptualRangeWidth, binWidth: currentBinWidthForNode, depth: depth, binsPerNode: this.binsPerNode };
            }
            
            lookup(lookupKey) {
                if (this.root.isEmptyNode) return { position: 0, steps: [{isFinalStep:true, finalPos:0, message: "Hist-Tree is empty."}]};
                if (lookupKey < this.globalMinKey) return { position: 0, steps: [{isFinalStep:true, finalPos:0, message: `Key ${lookupKey} < min.`}] };
                if (lookupKey > this.globalMaxKey) return { position: this.data.length, steps: [{isFinalStep:true, finalPos:this.data.length, message: `Key ${lookupKey} > max.`}] };

                const steps = [];
                let currentNode = this.root;
                let keyAdjustedForNode = lookupKey - currentNode.effectiveMinKey;
                let currentPositionEstimate = 0;

                while (currentNode && !currentNode.isLeaf && !currentNode.isEmptyNode) {
                    const nodeBinWidth = currentNode.binWidth;
                    let calculatedBinIndex = 0;
                    if(nodeBinWidth > 1e-9) calculatedBinIndex = Math.floor(keyAdjustedForNode / nodeBinWidth);
                    calculatedBinIndex = Math.max(0, Math.min(calculatedBinIndex, this.binsPerNode - 1));

                    steps.push({
                        nodeId: currentNode.id, 
                        nodeSnapshot: { effectiveMinKey: currentNode.effectiveMinKey, conceptualRangeWidth: currentNode.conceptualRangeWidth, binWidth: nodeBinWidth, histogram: [...currentNode.histogram], depth: currentNode.depth },
                        calculatedBinIndex: calculatedBinIndex, positionEstimateBeforeThisNode: currentPositionEstimate, lookupKeyForContext: lookupKey, keyAdjustedForThisNode: keyAdjustedForNode + currentNode.effectiveMinKey
                    });

                    for (let i = 0; i < calculatedBinIndex; i++) { currentPositionEstimate += (currentNode.histogram[i] || 0); }

                    if (!currentNode.children || !currentNode.children[calculatedBinIndex]) { break; } // Path ends here, move to final search
                    currentNode = currentNode.children[calculatedBinIndex];
                    keyAdjustedForNode -= calculatedBinIndex * nodeBinWidth; // Adjust key for child's perspective
                }
                
                // Determine final search parameters based on where the loop terminated
                const lastProcessedNodeSnapshot = steps.length > 0 ? steps[steps.length-1].nodeSnapshot : this.root; // Fallback to root if no steps (e.g. root is leaf)
                const lastCalculatedBinIndex = steps.length > 0 ? steps[steps.length-1].calculatedBinIndex : 0;

                let itemsInFinalPathSegment;
                if (currentNode && currentNode.isLeaf) { // Landed on a leaf node
                    itemsInFinalPathSegment = currentNode.histogram[0] || 0;
                } else { // Path ended in an internal node (bin pointed to no child)
                    itemsInFinalPathSegment = (lastProcessedNodeSnapshot.histogram && lastProcessedNodeSnapshot.histogram[lastCalculatedBinIndex] !== undefined) ? lastProcessedNodeSnapshot.histogram[lastCalculatedBinIndex] : 0;
                }
                
                const finalSearchStart = currentPositionEstimate;
                const finalSearchEnd = currentPositionEstimate + itemsInFinalPathSegment -1;

                const exactPos = this.binarySearchInDataSegment(this.data, lookupKey, Math.max(0, finalSearchStart), Math.min(this.data.length - 1, finalSearchEnd));
                steps.push({ isFinalStep: true, finalPos: exactPos, terminalBinSize: itemsInFinalPathSegment, searchRangeStart: finalSearchStart, searchRangeEnd: finalSearchEnd });
                return { position: exactPos, steps: steps };
            }

            binarySearchInDataSegment(arr, key, low, high) {
                low = Math.max(0, Math.min(low, arr.length -1)); high = Math.max(low, Math.min(high, arr.length -1));
                if (arr.length === 0 || low > high) return low;
                let l = low, r = high, ans = r + 1;
                while (l <= r) { const mid = Math.floor((l + r) / 2); if (arr[mid] >= key) { ans = mid; r = mid - 1; } else { l = mid + 1; } }
                return ans;
            }
        }

        // --- CompactHistTree (CHT) Class ---
        class CompactHistTree {
             constructor(histTreeInstance) {
                this.originalHistTree = histTreeInstance;
                this.data = histTreeInstance.data;
                this.binsPerNode = histTreeInstance.binsPerNode;
                this.compactTable = [];
                this.nodeToRowIndexMap = new Map(); 

                if (histTreeInstance.root && !histTreeInstance.root.isEmptyNode) { 
                    this.flattenTreeRecursive(histTreeInstance.root, 0);
                } else if (histTreeInstance.root && histTreeInstance.root.isEmptyNode) {
                    const emptyRootBins = Array(this.binsPerNode).fill({ isTerminal: true, value: 0 });
                    if (this.binsPerNode > 0) emptyRootBins[0] = { isTerminal: true, value: 0 };
                    else emptyRootBins.push({ isTerminal: true, value: 0 });
                    this.compactTable.push({
                        originalHistNodeId: histTreeInstance.root.id, depth: 0, effectiveMinKey: 0,
                        conceptualRangeWidth: 1, binWidth: 1, bins: emptyRootBins
                    });
                }
            }

            flattenTreeRecursive(histNode, cumulativeDataOffsetBeforeThisNode) {
                if (!histNode || this.nodeToRowIndexMap.has(histNode.id)) return cumulativeDataOffsetBeforeThisNode;
                const currentRowIndex = this.compactTable.length;
                this.nodeToRowIndexMap.set(histNode.id, currentRowIndex);

                const chtRow = {
                    originalHistNodeId: histNode.id, depth: histNode.depth, effectiveMinKey: histNode.effectiveMinKey,
                    conceptualRangeWidth: histNode.conceptualRangeWidth, binWidth: histNode.binWidth, bins: []
                };
                this.compactTable.push(chtRow);
                let dataOffsetWithinThisNode = 0;

                for (let i = 0; i < this.binsPerNode; i++) {
                    const childHistNode = (histNode.children && histNode.children[i]) ? histNode.children[i] : null;
                    const itemsInCurrentHistBin = (histNode.histogram && histNode.histogram[i] !== undefined) ? histNode.histogram[i] : 0;
                    if (childHistNode) chtRow.bins.push({ isTerminal: false, childHistNodeRefId: childHistNode.id }); 
                    else chtRow.bins.push({ isTerminal: true, value: cumulativeDataOffsetBeforeThisNode + dataOffsetWithinThisNode });
                    dataOffsetWithinThisNode += itemsInCurrentHistBin;
                }
                
                let recursiveDataOffsetTracker = 0;
                for (let i = 0; i < this.binsPerNode; i++) {
                    const chtBinEntry = chtRow.bins[i]; 
                    const itemsInCurrentHistBin = (histNode.histogram && histNode.histogram[i] !== undefined) ? histNode.histogram[i] : 0;
                    if (chtBinEntry.childHistNodeRefId) { 
                        const actualChildNode = histNode.children[i]; 
                        if (actualChildNode) { 
                           this.flattenTreeRecursive(actualChildNode, cumulativeDataOffsetBeforeThisNode + recursiveDataOffsetTracker);
                           chtRow.bins[i].value = this.nodeToRowIndexMap.get(chtBinEntry.childHistNodeRefId); 
                           delete chtBinEntry.childHistNodeRefId; 
                        } else { 
                            chtRow.bins[i].isTerminal = true; chtRow.bins[i].value = cumulativeDataOffsetBeforeThisNode + recursiveDataOffsetTracker;
                            delete chtBinEntry.childHistNodeRefId;
                        }
                    }
                    recursiveDataOffsetTracker += itemsInCurrentHistBin;
                }
                return cumulativeDataOffsetBeforeThisNode + dataOffsetWithinThisNode;
            }
            lookup(lookupKey) {
                if (!this.compactTable || this.compactTable.length === 0) return { position: 0, steps: [{isFinalStep:true, message:"CHT is empty."}] };
                if (lookupKey < this.originalHistTree.globalMinKey) return { position: 0, steps: [{isFinalStep:true, finalPos:0, message: `Key ${lookupKey} < min.`}] };
                if (lookupKey > this.originalHistTree.globalMaxKey) return { position: this.data.length, steps: [{isFinalStep:true, finalPos:this.data.length, message: `Key ${lookupKey} > max.`}] };

                const steps = [];
                let currentRowIndex = 0;
                while (currentRowIndex < this.compactTable.length) {
                    const currentRow = this.compactTable[currentRowIndex];
                    const keyRelativeToNodeStart = lookupKey - currentRow.effectiveMinKey;
                    
                    let binIndex = 0;
                    if(currentRow.binWidth > 1e-9) binIndex = Math.floor(keyRelativeToNodeStart / currentRow.binWidth);
                    binIndex = Math.max(0, Math.min(binIndex, this.binsPerNode - 1));
                    
                    const selectedCHTBin = currentRow.bins[binIndex];
                    steps.push({ rowIndex: currentRowIndex, nodeDepth: currentRow.depth, nodeEffectiveMinKey: currentRow.effectiveMinKey, calculatedBinIndex: binIndex, chtBinValue: selectedCHTBin.value, isTerminalBin: selectedCHTBin.isTerminal });

                    if (selectedCHTBin.isTerminal) {
                        const estimatedPos = selectedCHTBin.value;
                        const searchStart = Math.max(0, estimatedPos);
                        const searchEnd = Math.min(this.data.length - 1, estimatedPos + (this.originalHistTree.terminalThreshold || 5) * 2 ); 
                        const finalPosition = this.originalHistTree.binarySearchInDataSegment(this.data, lookupKey, searchStart, searchEnd);
                        steps.push({ isFinalStep: true, finalPos: finalPosition, searchedRange: `[${searchStart}-${searchEnd}]`, fromChtPos: estimatedPos });
                        return { position: finalPosition, steps: steps };
                    } else {
                        currentRowIndex = selectedCHTBin.value; // Jump to next row
                    }
                    if (steps.length > (this.originalHistTree.maxAllowedDepth || 10) + 15) { steps.push({isFinalStep: true, message: "Max lookup depth in CHT."}); return {position:0, steps:steps};}
                }
                steps.push({isFinalStep: true, message: "CHT Lookup path ended unexpectedly."}); return { position: this.data.length, steps: steps };
            }
        }

        // --- Global Variables & DOM Event Listeners ---
        let data = [];
        let histTree = null;
        let cht = null;
        let histTreeNodeElements = {}; 

        document.getElementById('generate-build').addEventListener('click', generateDataAndBuildTrees);
        document.getElementById('do-lookup').addEventListener('click', performLookupInBoth);

        function generateDataAndBuildTrees() {
            const errorDisplay = document.getElementById('error-display');
            errorDisplay.style.display = 'none'; errorDisplay.innerHTML = '';
            
            const size = parseInt(document.getElementById('data-size').value);
            const min = parseInt(document.getElementById('data-min').value);
            const max = parseInt(document.getElementById('data-max').value);
            data = [];
            if (size > 0 && min <= max) {
                for (let i = 0; i < size; i++) { data.push(Math.floor(Math.random() * (max - min + 1)) + min); }
                data.sort((a, b) => a - b);
            } else if (min > max) { errorDisplay.textContent = "Min > Max."; errorDisplay.style.display = 'block'; return; }
            
            document.getElementById('generated-data').textContent = data.length > 0 ? (data.length > 100 ? data.slice(0,50).join(', ') + `... (${data.length-100} more) ...` + data.slice(-50).join(', ') : data.join(', ')) : "No data generated.";

            const binsPerNode = parseInt(document.getElementById('bins-count').value);
            const terminalThreshold = parseInt(document.getElementById('bin-threshold').value);

            // Reset visualizations and info
            clearVisualsAndMetrics();

            try {
                let htBuildStart = performance.now();
                histTree = new HistTree(data, binsPerNode, terminalThreshold);
                let htBuildEnd = performance.now();
                let htBuildTime = (htBuildEnd - htBuildStart).toFixed(2);

                document.getElementById('hist-tree-info').innerHTML = `<p>Nodes: ${histTree.nodeIdCounter}, Max Depth Allowed: ${histTree.maxAllowedDepth}</p><p>Root Eff.Min: ${histTree.rootEffectiveMinKey.toFixed(0)}, Root Range: ${histTree.rootConceptualRangeWidth.toFixed(0)}</p>`;
                visualizeHistTreeStructure();

                let chtBuildStart = performance.now();
                cht = new CompactHistTree(histTree); 
                let chtBuildEnd = performance.now();
                let chtBuildTime = (chtBuildEnd - chtBuildStart).toFixed(2);
                
                document.getElementById('build-time-metrics').innerHTML = `<h3>Build Time</h3>
                    <p>Hist-Tree: ${htBuildTime} ms</p>
                    <p>CHT (from Hist-Tree): ${chtBuildTime} ms</p>
                    <p>Total: ${(parseFloat(htBuildTime) + parseFloat(chtBuildTime)).toFixed(2)} ms</p>`;

                document.getElementById('cht-info').innerHTML = `<p>CHT Table Rows: ${cht.compactTable.length}</p>`;
                visualizeCHTTable();
                updateStructureSizeGraph(histTree.nodeIdCounter, cht.compactTable.length);


                document.getElementById('lookup-result-area').textContent = "Trees built. Enter key to lookup.";

            } catch (e) {
                console.error("Error building trees:", e, e.stack);
                errorDisplay.innerHTML = `<p>Build Error: ${e.message}. Check console.</p>`;
                errorDisplay.style.display = 'block';
            }
        }

        function clearVisualsAndMetrics() {
            document.getElementById('hist-tree-structure-viz').innerHTML = '';
            document.getElementById('cht-table-viz').innerHTML = '<p>CHT table will be rendered here.</p>';
            document.getElementById('hist-tree-lookup-steps').innerHTML = '<h4>Hist-Tree Lookup Path:</h4>';
            document.getElementById('cht-lookup-steps').innerHTML = '<h4>CHT Lookup Path:</h4>';
            document.getElementById('performance-bars').innerHTML = '';
            document.getElementById('size-bars').innerHTML = '';
            document.getElementById('build-time-metrics').innerHTML = '<h3>Build Time</h3>';
             const summaries = document.querySelectorAll('.perf-summary');
            summaries.forEach(s => s.innerHTML = '');
        }
        
        function visualizeHistTreeStructure() { /* ... (same as before) ... */ 
            const container = document.getElementById('hist-tree-structure-viz');
            container.innerHTML = ''; histTreeNodeElements = {};
            if (!histTree || !histTree.root) { container.textContent = "Hist-Tree not built."; return; }

            function renderNode(node, level) {
                if(!node) return;
                const nodeContainer = document.createElement('div');
                nodeContainer.className = 'hist-tree-node-container';
                nodeContainer.style.marginLeft = level * 10 + 'px'; // Reduced indent for space
                nodeContainer.id = node.id; 
                histTreeNodeElements[node.id] = nodeContainer;

                if (node.isEmptyNode) { 
                    const binDiv = document.createElement('div'); binDiv.className = 'hist-tree-bin hist-tree-bin-terminal';
                    binDiv.innerHTML = `Empty`; nodeContainer.appendChild(binDiv);
                }
                else if (node.isLeaf) {
                    const binDiv = document.createElement('div'); binDiv.className = 'hist-tree-bin hist-tree-bin-terminal';
                    binDiv.innerHTML = `R:[${node.effectiveMinKey.toFixed(0)}-${(node.effectiveMinKey + node.conceptualRangeWidth -1).toFixed(0)}]<br>C:${node.histogram[0]}(L)`;
                    nodeContainer.appendChild(binDiv);
                } else {
                    for (let i = 0; i < node.binsPerNode; i++) {
                        const binDiv = document.createElement('div');
                        const hasChild = node.children && node.children[i];
                        binDiv.className = `hist-tree-bin ${hasChild ? 'hist-tree-bin-non-terminal' : 'hist-tree-bin-terminal'}`;
                        const binStart = node.effectiveMinKey + i * node.binWidth;
                        const binEnd = node.effectiveMinKey + (i + 1) * node.binWidth - 1;
                        binDiv.innerHTML = `[${binStart.toFixed(0)}-${binEnd.toFixed(0)}]<br>C:${node.histogram[i] || 0}`;
                        if (hasChild) { const conn = document.createElement('div'); conn.className = 'hist-tree-connector'; binDiv.appendChild(conn); }
                        nodeContainer.appendChild(binDiv);
                    }
                }
                container.appendChild(nodeContainer);
                if (!node.isLeaf && node.children) {
                    node.children.forEach(child => { if(child) renderNode(child, level + 1); });
                }
            }
            renderNode(histTree.root, 0);
        }

        function visualizeCHTTable() { /* ... (same as before, ensure cht.binsPerNode is used) ... */
            const container = document.getElementById('cht-table-viz');
            if (!cht || !cht.compactTable || cht.compactTable.length === 0) { container.innerHTML = "<p>CHT not built or is empty.</p>"; return; }
            
            let tableHtml = '<table class="cht-table"><thead><tr><th>Row (D)</th>';
            const currentBinsPerNode = cht.binsPerNode || (cht.compactTable[0] ? cht.compactTable[0].bins.length : 0); // Handle if binsPerNode not directly on cht
            for (let i = 0; i < currentBinsPerNode; i++) { tableHtml += `<th>B${i}</th>`; }
            tableHtml += '<th>Eff.Min</th></tr></thead><tbody>';

            cht.compactTable.forEach((row, rowIndex) => {
                tableHtml += `<tr id="cht-row-${rowIndex}"><td>${rowIndex}(${row.depth})</td>`;
                const binsToRender = row.bins && row.bins.length === currentBinsPerNode ? row.bins : Array(currentBinsPerNode).fill({isTerminal:true, value:'N/A'});

                binsToRender.forEach((bin, binIndex) => {
                    const binClass = bin.isTerminal ? 'cht-bin-terminal' : 'cht-bin-offset';
                    const binTitle = bin.isTerminal ? `Term:Pos ${bin.value}` : (bin.value !== 'N/A' ? `Off:To ${bin.value}` : 'Inv');
                    tableHtml += `<td class="${binClass}" id="cht-row-${rowIndex}-bin-${binIndex}" title="${binTitle}">${bin.value}</td>`;
                });
                tableHtml += `<td>${row.effectiveMinKey.toFixed(0)}</td></tr>`;
            });
            tableHtml += '</tbody></table>';
            container.innerHTML = tableHtml;
        }

        function performLookupInBoth() { /* ... (same, calls updateLookupPerformanceGraph) ... */
            const errorDisplay = document.getElementById('error-display');
             errorDisplay.style.display = 'none'; errorDisplay.innerHTML = '';
            if (!histTree || !cht) { errorDisplay.textContent = 'Build trees first.'; errorDisplay.style.display = 'block'; return; }
            const keyInput = document.getElementById('lookup-key').value;
            if (keyInput === "") { errorDisplay.textContent = 'Enter key.'; errorDisplay.style.display = 'block'; return; }
            const keyToLookup = parseInt(keyInput);

            document.querySelectorAll('.hist-tree-highlighted-bin').forEach(el => el.classList.remove('hist-tree-highlighted-bin'));
            document.querySelectorAll('.cht-row-highlight').forEach(el => el.classList.remove('cht-row-highlight'));
            document.querySelectorAll('.cht-bin-highlight').forEach(el => el.classList.remove('cht-bin-highlight'));

            const histResult = histTree.lookup(keyToLookup);
            visualizeHistTreeLookupSteps(histResult.steps, keyToLookup);

            const chtResult = cht.lookup(keyToLookup); 
            visualizeCHLookupSteps(chtResult.steps, keyToLookup);
            
            const resultArea = document.getElementById('lookup-result-area');
            if (data.length > 0 || (histTree && histTree.root.isEmptyNode)) {
                 if (histResult.position < data.length && data[histResult.position] === keyToLookup) {
                    resultArea.innerText = `Key ${keyToLookup} FOUND at data index ${histResult.position}. (Val: ${data[histResult.position]})`;
                } else if (histResult.position < data.length) {
                    resultArea.innerText = `Key ${keyToLookup} NOT FOUND. Lower bound: index ${histResult.position} (Val: ${data[histResult.position]})`;
                } else { // result.position >= data.length
                    resultArea.innerText = `Key ${keyToLookup} > all keys. Lower bound: index ${histResult.position}.`;
                }
            } else { 
                resultArea.innerText = `Lookup for ${keyToLookup} on empty data. Pos: ${histResult.position}`;
            }

            if(data.length > 0 && histResult.position !== chtResult.position && !(histTree && histTree.root.isEmptyNode)) { 
                resultArea.innerText += ` (Warning: Positions mismatch! HT: ${histResult.position}, CHT: ${chtResult.position})`;
                resultArea.style.backgroundColor = "#ffcdd2";
            } else {
                 resultArea.style.backgroundColor = "#dfe8f0";
            }
            updateLookupPerformanceGraph(histResult.steps.length, chtResult.steps.length);
        }
        
        function updateStructureSizeGraph(histNodes, chtRows) {
            const barsContainer = document.getElementById('size-bars');
            barsContainer.innerHTML = ''; 
            const summaryDiv = document.querySelector('#structure-size-metrics .size-summary');
            summaryDiv.innerHTML = '';

            const maxSize = Math.max(histNodes, chtRows, 1); 
            const graphHeight = 80; // CSS height of .bars-area

            // Hist-Tree Nodes Bar
            const histBar = document.createElement('div');
            histBar.className = 'bar hist-tree-bar';
            const histHeight = (histNodes / maxSize) * graphHeight; 
            histBar.style.height = `${Math.max(5, histHeight)}px`; 
            const histLabel = document.createElement('span');
            histLabel.className = 'value-label'; histLabel.textContent = histNodes;
            histBar.appendChild(histLabel); barsContainer.appendChild(histBar);

            // CHT Rows Bar
            const chtBar = document.createElement('div');
            chtBar.className = 'bar cht-bar';
            const chtHeight = (chtRows / maxSize) * graphHeight;
            chtBar.style.height = `${Math.max(5, chtHeight)}px`;
            const chtLabel = document.createElement('span');
            chtLabel.className = 'value-label'; chtLabel.textContent = chtRows;
            chtBar.appendChild(chtLabel); barsContainer.appendChild(chtBar);
            
            let summaryText = "";
            if (chtRows < histNodes) summaryText = `<p style="color:green;">CHT has fewer rows than Hist-Tree has nodes (indicative of compactness).</p>`;
            else if (histNodes < chtRows) summaryText = `<p style="color:orange;">CHT has more rows than Hist-Tree nodes (unusual, check CHT flattening logic or very sparse Hist-Tree).</p>`;
            else summaryText = `<p>Similar number of primary structural elements.</p>`;
            if (summaryDiv) summaryDiv.innerHTML = summaryText;
        }

        function updateLookupPerformanceGraph(histSteps, chtSteps) { /* ... (same as before, targets #performance-bars and .lookup-summary) ... */
            const barsContainer = document.getElementById('performance-bars');
            barsContainer.innerHTML = ''; 
            const summaryDiv = document.querySelector('#lookup-performance-graph-container .lookup-summary');
            summaryDiv.innerHTML = '';

            const maxSteps = Math.max(histSteps, chtSteps, 1); 
            const graphHeight = 80; 

            const histBar = document.createElement('div');
            histBar.className = 'bar hist-tree-bar';
            const histHeight = (histSteps / maxSteps) * graphHeight; 
            histBar.style.height = `${Math.max(5, histHeight)}px`; 
            const histLabel = document.createElement('span');
            histLabel.className = 'value-label'; histLabel.textContent = histSteps;
            histBar.appendChild(histLabel); barsContainer.appendChild(histBar);

            const chtBar = document.createElement('div');
            chtBar.className = 'bar cht-bar';
            const chtHeight = (chtSteps / maxSteps) * graphHeight;
            chtBar.style.height = `${Math.max(5, chtHeight)}px`;
            const chtLabel = document.createElement('span');
            chtLabel.className = 'value-label'; chtLabel.textContent = chtSteps;
            chtBar.appendChild(chtLabel); barsContainer.appendChild(chtBar);

            let summaryText = "";
            if (chtSteps < histSteps) summaryText = `<p style="color:green;">CHT used fewer high-level steps.</p>`;
            else if (histSteps < chtSteps) summaryText = `<p style="color:orange;">Hist-Tree used fewer high-level steps.</p>`;
            else summaryText = `<p>Both used a similar number of high-level steps.</p>`;
            if (summaryDiv) summaryDiv.innerHTML = summaryText;
        }


        function visualizeHistTreeLookupSteps(steps, lookupKey) { /* ... (same as before) ... */
            const container = document.getElementById('hist-tree-lookup-steps');
            container.innerHTML = '<h4>Hist-Tree Lookup Path:</h4>';
            if (!steps) return;
            steps.forEach((step, idx) => {
                const stepDiv = document.createElement('div'); stepDiv.className = 'lookup-step-item'; let html = '';
                if (step.isFinalStep) {
                    stepDiv.classList.add('final-lookup-step');
                    html = `<p><b>Final (Key ${lookupKey}):</b> BinSearch [${step.searchRangeStart}-${step.searchRangeEnd}] (Size ${step.terminalBinSize || 0}) => Pos ${step.finalPos}</p>`;
                     if(step.message) html += `<p>${step.message}</p>`;
                } else {
                    html = `<p><b>Step ${idx+1} (Key ${lookupKey}):</b> Node (D${step.nodeSnapshot.depth}), Eff.Min: ${step.nodeSnapshot.effectiveMinKey.toFixed(0)}</p>
                            <p>Key adj: ${step.keyAdjustedForThisNode.toFixed(0)}, BinW: ${step.nodeSnapshot.binWidth.toFixed(1)} => Bin ${step.calculatedBinIndex}</p>`;
                    const nodeDiv = histTreeNodeElements[step.nodeId];
                    if (nodeDiv) { const binsInNode = nodeDiv.querySelectorAll('.hist-tree-bin'); if (step.calculatedBinIndex < binsInNode.length) binsInNode[step.calculatedBinIndex].classList.add('hist-tree-highlighted-bin'); }
                }
                stepDiv.innerHTML = html; container.appendChild(stepDiv);
            });
        }

        function visualizeCHLookupSteps(steps, lookupKey) { /* ... (same as before) ... */
            const container = document.getElementById('cht-lookup-steps');
            container.innerHTML = '<h4>CHT Lookup Path:</h4>';
            if(!steps) return;
            steps.forEach((step, idx) => {
                const stepDiv = document.createElement('div'); stepDiv.className = 'lookup-step-item'; let html = '';
                if (step.isFinalStep) {
                    stepDiv.classList.add('final-lookup-step');
                    html = `<p><b>Final (Key ${lookupKey}):</b> CHT Est.Pos: ${step.fromChtPos === undefined ? 'N/A' : step.fromChtPos}. Search ${step.searchedRange || 'N/A'}.</p><p><strong>=> Final Pos: ${step.finalPos}</strong></p>`;
                    if(step.message) html += `<p>${step.message}</p>`;
                } else {
                    html = `<p><b>Step ${idx + 1} (Key ${lookupKey}):</b> CHT Row ${step.rowIndex} (Node D${step.nodeDepth})</p>
                            <p>Eff.Min: ${step.nodeEffectiveMinKey.toFixed(1)} => Bin ${step.calculatedBinIndex}.</p>
                            <p>Val: ${step.chtBinValue} (${step.isTerminalBin ? 'Term' : 'Off:' + step.chtBinValue})</p>`;
                    const rowEl = document.getElementById(`cht-row-${step.rowIndex}`); if (rowEl) rowEl.classList.add('cht-row-highlight');
                    const binEl = document.getElementById(`cht-row-${step.rowIndex}-bin-${step.calculatedBinIndex}`); if (binEl) binEl.classList.add('cht-bin-highlight');
                }
                stepDiv.innerHTML = html; container.appendChild(stepDiv);
            });
        }
        // Initialize on load
        generateDataAndBuildTrees();
    </script>
</body>
</html>
